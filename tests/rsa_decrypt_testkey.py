# coding: utf-8
import hashlib
import time
import os

from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA
from Crypto.Random import get_random_bytes
from Crypto import Random
import binascii

from onlykey import OnlyKey, Message

print
'Initialize OnlyKey client...'
ok = OnlyKey()
print
'Done'
print

time.sleep(2)

ok.read_string(timeout_ms=100)
empty = 'a'
while not empty:
    empty = ok.read_string(timeout_ms=100)

time.sleep(1)
print
'You should see your OnlyKey blink 3 times'
print

print
'Enter RSA slot number to use for decryption (1 - 4)'
print
slot = int(raw_input())

print
'Trying to read the public RSA N part 1...'
ok.send_message(msg=Message.OKGETPUBKEY, payload=chr(slot))  # , payload=[1, 1])
time.sleep(1.5)
for _ in xrange(10):
    ok_pubkey1 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey1) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey1)

print
'Trying to read the public RSA N part 2...'
for _ in xrange(10):
    ok_pubkey2 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey2) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey2)

print
'Trying to read the public RSA N part 3...'
for _ in xrange(10):
    ok_pubkey3 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey3) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey3)

print
'Trying to read the public RSA N part 4...'
for _ in xrange(10):
    ok_pubkey4 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey4) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey4)

print
'Trying to read the public RSA N part 5...'
for _ in xrange(10):
    ok_pubkey5 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey5) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey5)

print
'Trying to read the public RSA N part 6...'
for _ in xrange(10):
    ok_pubkey6 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey6) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey6)

print
'Trying to read the public RSA N part 7...'
for _ in xrange(10):
    ok_pubkey7 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey7) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey7)

print
'Trying to read the public RSA N part 8...'
for _ in xrange(10):
    ok_pubkey8 = ok.read_bytes(64, to_str=True, timeout_ms=1000)
    if len(ok_pubkey8) == 64:
        break
    time.sleep(1)

print

print
'received=', repr(ok_pubkey8)

if not ok_pubkey2:
    raise Exception('failed to set the RSA key')

print
'Received Public Key generated by OnlyKey'
ok_pubkey = ok_pubkey1 + ok_pubkey2 + ok_pubkey3 + ok_pubkey4 + ok_pubkey5 + ok_pubkey6 + ok_pubkey7 + ok_pubkey8
print
'Public N=', repr(ok_pubkey)
print

print
'Key Size =', len(ok_pubkey)
print
random_generator = Random.new().read
key = RSA.generate((len(ok_pubkey) * 8), random_generator)  # generate pub and priv key
ok_pubkey = ok_pubkey.encode("HEX")

n = long(ok_pubkey, 16)
e = int('10001', 16)

key = RSA.construct((n, e))

print
'N =', repr(key.n)
print

message = 'Secret message'
# h = SHA.new(message)
cipher = PKCS1_v1_5.new(key)
ciphertext = cipher.encrypt(message)

# hex_enc_data = bin2hex(enc_data)
print
'encrypted payload = ', repr(ciphertext)
print

# Compute the challenge pin
h = hashlib.sha256()
h.update(ciphertext)
d = h.digest()

assert len(d) == 32


def get_button(byte):
    ibyte = ord(byte)
    if ibyte < 6:
        return 1
    return ibyte % 5 + 1


b1, b2, b3 = get_button(d[0]), get_button(d[15]), get_button(d[31])

print
'Sending the payload to the OnlyKey...'
ok.send_large_message2(msg=Message.OKDECRYPT, payload=ciphertext, slot_id=slot)

print
'Please enter the 3 digit challenge code on OnlyKey (and press ENTER if necessary)'
print
'{} {} {}'.format(b1, b2, b3)
raw_input()
print
'Trying to read the decrypted data from OnlyKey...'
ok_decrypted = ''
while ok_decrypted == '':
    time.sleep(0.5)
    ok_decrypted = ok.read_bytes(len(message), to_str=True)

print
'Decrypted by OnlyKey, data=', repr(ok_decrypted)

print
'Original Message =', repr(message)
print
'Assert that the original message matches the data generated on the OnlyKey'
assert repr(ok_decrypted) == repr(message)
print
'Ok, data matches'
print

print
'Done'
